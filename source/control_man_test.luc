module control_man_test #(
        ROWS = 2 : ROWS > 0,
        COLUMNS = 5 : COLUMNS > 0
    )(
        input clk,    // clock
        input rst,    // reset
        input button,
        input start,
        output matrix[ROWS][COLUMNS * 24]
    ) {
    
    const BIT_NUM = COLUMNS * 24;    
    const START_BLKNUM = (COLUMNS / 2) + 1;
    const REMAIN = COLUMNS - START_BLKNUM;
    
    .clk(clk), .rst(rst) {
        .button(button) {
            control ctl0(#SIZE(COLUMNS));
            control ctl1(#SIZE(COLUMNS));
        }
        
        fsm level_state = {IDLE, START, ROW1};
        dff start_signals[ROWS];
        dff storage[ROWS][BIT_NUM];
        dff output_array[ROWS][BIT_NUM];
    }

    always {
        matrix = output_array.q;
        ctl0.start_color = storage.q[0];
        ctl0.start = start_signals.q[0];
        ctl1.start_color = storage.q[1];
        ctl1.start_color = start_signals.q[1];
        
        case(level_state.q) {
            level_state.IDLE:
                if (start) {
                    level_state.d = level_state.START;
                }
            
            level_state.START:
            	start_signals.d[0] = b1;
                storage.d[0] = c{START_BLKNUMx{Color.GREEN}, REMAINx{Color.BLACK}};
                output_array.d[0] = ctl0.colors_out;
                if (ctl0.stop) {
                	level_state.d = level_state.ROW1;
                }

            level_state.ROW1:
            	start_signals.d[1] = b1;
            	storage.d[1] = c{START_BLKNUMx{Color.GREEN}, REMAINx{Color.BLACK}};
            	output_array.d[0] = ctl1.colors_out;
        }
        
    }
}
